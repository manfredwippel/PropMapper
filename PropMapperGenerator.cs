using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace DX.Shared.SourceGenerator
{
    /// <summary>
    /// Source generator that generates property mapping code at compile-time without using reflection.
    /// </summary>
    [Generator]
    public class PropMapperGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new PropMapperSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Retrieve the populated receiver
            if (!(context.SyntaxReceiver is PropMapperSyntaxReceiver receiver))
                return;

            var compilation = context.Compilation;
            var mappings = new HashSet<(INamedTypeSymbol, INamedTypeSymbol)>(new TypePairComparer());

            // Find all invocations of our extension methods
            foreach (var invocation in receiver.Invocations)
            {
                var model = compilation.GetSemanticModel(invocation.SyntaxTree);
                var symbolInfo = model.GetSymbolInfo(invocation);
                
                if (symbolInfo.Symbol is IMethodSymbol methodSymbol)
                {
                    // Check if this is one of our extension methods
                    if (methodSymbol.ContainingType?.Name == "ClassClonator" &&
                        methodSymbol.ContainingNamespace?.ToDisplayString() == "DX.Shared")
                    {
                        // Extract type parameters
                        if (methodSymbol.TypeArguments.Length == 2)
                        {
                            var inputType = methodSymbol.TypeArguments[0] as INamedTypeSymbol;
                            var outputType = methodSymbol.TypeArguments[1] as INamedTypeSymbol;
                            
                            if (inputType != null && outputType != null)
                            {
                                mappings.Add((inputType, outputType));
                            }
                        }
                    }
                }
            }

            // Generate mapping code for each discovered type pair
            if (mappings.Count > 0)
            {
                var source = GenerateMappingCode(mappings);
                context.AddSource("PropMapperGenerated.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        private string GenerateMappingCode(HashSet<(INamedTypeSymbol Input, INamedTypeSymbol Output)> mappings)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace DX.Shared.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    using System;");
            sb.AppendLine("    using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Generated property mappers without reflection.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class GeneratedPropMapper");
            sb.AppendLine("    {");

            foreach (var (inputType, outputType) in mappings)
            {
                GenerateMapperMethods(sb, inputType, outputType);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private void GenerateMapperMethods(StringBuilder sb, INamedTypeSymbol inputType, INamedTypeSymbol outputType)
        {
            var inputProps = GetReadableProperties(inputType);
            var outputProps = GetWritableProperties(outputType);
            
            // Match properties by name
            var matchedProps = inputProps
                .Join(outputProps, 
                    ip => ip.Name, 
                    op => op.Name, 
                    (ip, op) => new { Input = ip, Output = op })
                .ToList();

            var methodSuffix = $"{SanitizeTypeName(inputType)}_To_{SanitizeTypeName(outputType)}";

            // Generate CreateCopy method
            sb.AppendLine();
            sb.AppendLine($"        public static {GetFullTypeName(outputType)} CreateCopy_{methodSuffix}({GetFullTypeName(inputType)} input)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var output = new {GetFullTypeName(outputType)}();");
            
            foreach (var prop in matchedProps)
            {
                sb.AppendLine($"            output.{prop.Output.Name} = input.{prop.Input.Name};");
            }
            
            sb.AppendLine("            return output;");
            sb.AppendLine("        }");

            // Generate CopyTo method
            sb.AppendLine();
            sb.AppendLine($"        public static bool CopyTo_{methodSuffix}({GetFullTypeName(inputType)} input, {GetFullTypeName(outputType)} output)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (input is null || output is null)");
            sb.AppendLine("            {");
            sb.AppendLine("                return false;");
            sb.AppendLine("            }");
            
            foreach (var prop in matchedProps)
            {
                sb.AppendLine($"            output.{prop.Output.Name} = input.{prop.Input.Name};");
            }
            
            sb.AppendLine("            return true;");
            sb.AppendLine("        }");

            // Generate CopyAll method
            sb.AppendLine();
            sb.AppendLine($"        public static IEnumerable<{GetFullTypeName(outputType)}> CopyAll_{methodSuffix}(IEnumerable<{GetFullTypeName(inputType)}> inputArr)");
            sb.AppendLine("        {");
            sb.AppendLine("            foreach (var input in inputArr)");
            sb.AppendLine("            {");
            sb.AppendLine("                if (input is not null)");
            sb.AppendLine("                {");
            sb.AppendLine($"                    yield return CreateCopy_{methodSuffix}(input);");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
        }

        private List<IPropertySymbol> GetReadableProperties(INamedTypeSymbol type)
        {
            var properties = new List<IPropertySymbol>();
            
            foreach (var member in type.GetMembers())
            {
                if (member is IPropertySymbol prop && 
                    prop.DeclaredAccessibility == Accessibility.Public && 
                    !prop.IsStatic &&
                    prop.GetMethod != null)
                {
                    properties.Add(prop);
                }
            }
            
            return properties;
        }

        private List<IPropertySymbol> GetWritableProperties(INamedTypeSymbol type)
        {
            var properties = new List<IPropertySymbol>();
            
            foreach (var member in type.GetMembers())
            {
                if (member is IPropertySymbol prop && 
                    prop.DeclaredAccessibility == Accessibility.Public && 
                    !prop.IsStatic &&
                    prop.SetMethod != null)
                {
                    properties.Add(prop);
                }
            }
            
            return properties;
        }

        private string GetFullTypeName(INamedTypeSymbol type)
        {
            return type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        private string SanitizeTypeName(INamedTypeSymbol type)
        {
            var name = type.ToDisplayString()
                .Replace(".", "_")
                .Replace("<", "_")
                .Replace(">", "_")
                .Replace(",", "_")
                .Replace(" ", "")
                .Replace("[]", "Array");
            return name;
        }

        private class TypePairComparer : IEqualityComparer<(INamedTypeSymbol, INamedTypeSymbol)>
        {
            public bool Equals((INamedTypeSymbol, INamedTypeSymbol) x, (INamedTypeSymbol, INamedTypeSymbol) y)
            {
                return SymbolEqualityComparer.Default.Equals(x.Item1, y.Item1) &&
                       SymbolEqualityComparer.Default.Equals(x.Item2, y.Item2);
            }

            public int GetHashCode((INamedTypeSymbol, INamedTypeSymbol) obj)
            {
                return (SymbolEqualityComparer.Default.GetHashCode(obj.Item1),
                        SymbolEqualityComparer.Default.GetHashCode(obj.Item2)).GetHashCode();
            }
        }
    }

    /// <summary>
    /// Syntax receiver that collects invocation expressions for analysis.
    /// </summary>
    internal class PropMapperSyntaxReceiver : ISyntaxReceiver
    {
        public List<InvocationExpressionSyntax> Invocations { get; } = new List<InvocationExpressionSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Collect all invocation expressions
            if (syntaxNode is InvocationExpressionSyntax invocation)
            {
                Invocations.Add(invocation);
            }
        }
    }
}

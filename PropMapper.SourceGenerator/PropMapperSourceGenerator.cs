using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace DX.Shared.SourceGenerator
{
    [Generator]
    public class PropMapperSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all generic name syntax that could be CloneMapper<,> or CopyMapper<,>
            var mapperUsages = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsMapperUsage(s),
                    transform: static (ctx, _) => GetMapperTypeArguments(ctx))
                .Where(static m => m != null);

            // Combine with compilation
            var compilationAndMappers = context.CompilationProvider.Combine(mapperUsages.Collect());

            // Generate source
            context.RegisterSourceOutput(compilationAndMappers,
                static (spc, source) => Execute(source.Left, source.Right, spc));
        }

        private static bool IsMapperUsage(SyntaxNode node)
        {
            // Look for generic names like CloneMapper<X, Y> or CopyMapper<X, Y>
            if (node is GenericNameSyntax genericName)
            {
                var name = genericName.Identifier.Text;
                return name == "CloneMapper" || name == "CopyMapper";
            }

            // Also look for extension method calls
            if (node is InvocationExpressionSyntax invocation)
            {
                var expression = invocation.Expression.ToString();
                return expression.Contains("CopyTo") ||
                       expression.Contains("CopyFrom") ||
                       expression.Contains("CreateCopy") ||
                       expression.Contains("CopyAll");
            }

            return false;
        }

        private static MapperTypePair? GetMapperTypeArguments(GeneratorSyntaxContext context)
        {
            if (context.Node is GenericNameSyntax genericName)
            {
                if (genericName.TypeArgumentList.Arguments.Count == 2)
                {
                    var semanticModel = context.SemanticModel;
                    var typeInfo1 = semanticModel.GetTypeInfo(genericName.TypeArgumentList.Arguments[0]);
                    var typeInfo2 = semanticModel.GetTypeInfo(genericName.TypeArgumentList.Arguments[1]);

                    if (typeInfo1.Type is INamedTypeSymbol sourceType &&
                        typeInfo2.Type is INamedTypeSymbol destType)
                    {
                        return new MapperTypePair(sourceType, destType);
                    }
                }
            }
            else if (context.Node is InvocationExpressionSyntax invocation)
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(invocation);
                if (symbolInfo.Symbol is IMethodSymbol methodSymbol &&
                    methodSymbol.TypeArguments.Length == 2)
                {
                    if (methodSymbol.TypeArguments[0] is INamedTypeSymbol sourceType &&
                        methodSymbol.TypeArguments[1] is INamedTypeSymbol destType)
                    {
                        return new MapperTypePair(sourceType, destType);
                    }
                }
            }

            return null;
        }

        private static void Execute(Compilation compilation, ImmutableArray<MapperTypePair?> mappers, SourceProductionContext context)
        {
            if (mappers.IsDefaultOrEmpty)
                return;

            // Get unique type pairs
            var uniquePairs = mappers
                .Where(m => m != null)
                .GroupBy(m => (m!.SourceType, m.DestinationType), new TypePairComparer())
                .Select(g => g.First()!)
                .ToList();

            if (uniquePairs.Count == 0)
                return;

            // Generate the registry implementation
            GenerateMapperRegistry(context, uniquePairs);

            // Generate implementations for each type pair
            foreach (var pair in uniquePairs)
            {
                GenerateMapperImplementation(context, pair.SourceType, pair.DestinationType);
            }
        }

        private static void GenerateMapperRegistry(SourceProductionContext context, List<MapperTypePair> typePairs)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// Generated by PropMapper Source Generator");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine();
            sb.AppendLine("namespace DX.Shared");
            sb.AppendLine("{");
            sb.AppendLine("    internal static partial class MapperRegistry");
            sb.AppendLine("    {");
            
            // Generate GetCloneMapper method
            sb.AppendLine("        public static partial IMapper<TInput, TOutput>? GetCloneMapper<TInput, TOutput>() where TOutput : new()");
            sb.AppendLine("        {");
            sb.AppendLine("            var sourceType = typeof(TInput);");
            sb.AppendLine("            var destType = typeof(TOutput);");
            sb.AppendLine();
            
            foreach (var pair in typePairs)
            {
                var sourceTypeName = pair.SourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var destTypeName = pair.DestinationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var sourceSimpleName = SanitizeTypeName(pair.SourceType.Name);
                var destSimpleName = SanitizeTypeName(pair.DestinationType.Name);
                
                sb.AppendLine($"            if (sourceType == typeof({sourceTypeName}) && destType == typeof({destTypeName}))");
                sb.AppendLine($"                return (IMapper<TInput, TOutput>?)(object?)new CloneMapperImpl_{sourceSimpleName}_To_{destSimpleName}();");
            }
            
            sb.AppendLine();
            sb.AppendLine("            return null;");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // Generate GetCopyMapper method
            sb.AppendLine("        public static partial ICopyMapper<TInput, TOutput>? GetCopyMapper<TInput, TOutput>()");
            sb.AppendLine("        {");
            sb.AppendLine("            var sourceType = typeof(TInput);");
            sb.AppendLine("            var destType = typeof(TOutput);");
            sb.AppendLine();
            
            foreach (var pair in typePairs)
            {
                var sourceTypeName = pair.SourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var destTypeName = pair.DestinationType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var sourceSimpleName = SanitizeTypeName(pair.SourceType.Name);
                var destSimpleName = SanitizeTypeName(pair.DestinationType.Name);
                
                sb.AppendLine($"            if (sourceType == typeof({sourceTypeName}) && destType == typeof({destTypeName}))");
                sb.AppendLine($"                return (ICopyMapper<TInput, TOutput>?)(object?)new CopyMapperImpl_{sourceSimpleName}_To_{destSimpleName}();");
            }
            
            sb.AppendLine();
            sb.AppendLine("            return null;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource("PropMapper.MapperRegistry.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static void GenerateMapperImplementation(SourceProductionContext context, INamedTypeSymbol sourceType, INamedTypeSymbol destType)
        {
            // Get fully qualified type names
            var sourceTypeName = sourceType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var destTypeName = destType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            // Get simple names for the file name
            var sourceSimpleName = SanitizeTypeName(sourceType.Name);
            var destSimpleName = SanitizeTypeName(destType.Name);

            // Get properties
            var sourceProps = GetPublicReadableProperties(sourceType);
            var destProps = GetPublicWritableProperties(destType);

            // Match properties by name and type
            var matchingProps = sourceProps
                .Join(destProps,
                    sp => sp.Name,
                    dp => dp.Name,
                    (sp, dp) => new { Source = sp, Dest = dp })
                .Where(p => SymbolEqualityComparer.Default.Equals(p.Source.Type, p.Dest.Type))
                .ToList();

            if (matchingProps.Count == 0)
            {
                // No properties to map, skip generation
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// Generated by PropMapper Source Generator");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace DX.Shared");
            sb.AppendLine("{");

            // Generate CloneMapper implementation class
            sb.AppendLine($"    internal sealed class CloneMapperImpl_{sourceSimpleName}_To_{destSimpleName} : IMapper<{sourceTypeName}, {destTypeName}>");
            sb.AppendLine("    {");
            sb.AppendLine($"        public {destTypeName} Map({sourceTypeName} input)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var output = new {destTypeName}();");
            
            foreach (var prop in matchingProps)
            {
                sb.AppendLine($"            output.{prop.Dest.Name} = input.{prop.Source.Name};");
            }
            
            sb.AppendLine("            return output;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();

            // Generate CopyMapper implementation class
            sb.AppendLine($"    internal sealed class CopyMapperImpl_{sourceSimpleName}_To_{destSimpleName} : ICopyMapper<{sourceTypeName}, {destTypeName}>");
            sb.AppendLine("    {");
            sb.AppendLine($"        public void CopyTo({sourceTypeName} input, {destTypeName} output)");
            sb.AppendLine("        {");
            
            foreach (var prop in matchingProps)
            {
                sb.AppendLine($"            output.{prop.Dest.Name} = input.{prop.Source.Name};");
            }
            
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            var fileName = $"PropMapper.{sourceSimpleName}_To_{destSimpleName}.g.cs";
            context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static List<IPropertySymbol> GetPublicReadableProperties(INamedTypeSymbol type)
        {
            var props = new List<IPropertySymbol>();

            var currentType = type;
            while (currentType != null)
            {
                foreach (var member in currentType.GetMembers())
                {
                    if (member is IPropertySymbol prop &&
                        prop.DeclaredAccessibility == Accessibility.Public &&
                        !prop.IsStatic &&
                        prop.GetMethod != null &&
                        prop.GetMethod.DeclaredAccessibility == Accessibility.Public)
                    {
                        // Check if we already have this property (from derived class)
                        if (!props.Any(p => p.Name == prop.Name))
                        {
                            props.Add(prop);
                        }
                    }
                }
                currentType = currentType.BaseType;
            }

            return props;
        }

        private static List<IPropertySymbol> GetPublicWritableProperties(INamedTypeSymbol type)
        {
            var props = new List<IPropertySymbol>();

            var currentType = type;
            while (currentType != null)
            {
                foreach (var member in currentType.GetMembers())
                {
                    if (member is IPropertySymbol prop &&
                        prop.DeclaredAccessibility == Accessibility.Public &&
                        !prop.IsStatic &&
                        prop.SetMethod != null &&
                        prop.SetMethod.DeclaredAccessibility == Accessibility.Public)
                    {
                        // Check if we already have this property (from derived class)
                        if (!props.Any(p => p.Name == prop.Name))
                        {
                            props.Add(prop);
                        }
                    }
                }
                currentType = currentType.BaseType;
            }

            return props;
        }

        private static string SanitizeTypeName(string name)
        {
            // Remove generic markers and special characters that can't be in file names
            return name
                .Replace("<", "_")
                .Replace(">", "_")
                .Replace(",", "_")
                .Replace(" ", "")
                .Replace("`", "_");
        }

        private class MapperTypePair
        {
            public INamedTypeSymbol SourceType { get; }
            public INamedTypeSymbol DestinationType { get; }

            public MapperTypePair(INamedTypeSymbol sourceType, INamedTypeSymbol destinationType)
            {
                SourceType = sourceType;
                DestinationType = destinationType;
            }
        }

        private class TypePairComparer : IEqualityComparer<(INamedTypeSymbol, INamedTypeSymbol)>
        {
            public bool Equals((INamedTypeSymbol, INamedTypeSymbol) x, (INamedTypeSymbol, INamedTypeSymbol) y)
            {
                return SymbolEqualityComparer.Default.Equals(x.Item1, y.Item1) &&
                       SymbolEqualityComparer.Default.Equals(x.Item2, y.Item2);
            }

            public int GetHashCode((INamedTypeSymbol, INamedTypeSymbol) obj)
            {
                unchecked
                {
                    int hash = 17;
                    hash = hash * 23 + SymbolEqualityComparer.Default.GetHashCode(obj.Item1);
                    hash = hash * 23 + SymbolEqualityComparer.Default.GetHashCode(obj.Item2);
                    return hash;
                }
            }
        }
    }
}
